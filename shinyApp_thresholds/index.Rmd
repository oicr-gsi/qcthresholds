---
title: "cfMeDIP-seq QC thresholding"
author: "Prisni Rath"
date: "15/10/2021"
output: html_document
# output: flexdashboard::flex_dashboard
runtime: shiny
---

```{r setup, include=FALSE, echo=FALSE}
# load essential libraries
knitr::opts_chunk$set(echo = TRUE)
library(shiny)
library(ggplot2)
library(gtools)
library(reshape2)
```

## GOAL
To assess the QC thresholds for 
\
1) Methylation beta
\
2) Relative CpG Frequency in regions
\
```{r, echo=FALSE}

# read the metrics table from dashi
data_file <- "data/all_cfMedips_projects_summary.tsv"
data.medips <- read.csv(data_file, sep = "\t", as.is = T)
# dim(data.medips) #7352   87
# restricting to CM geo_library_source_template_type
data.medips <- data.medips[data.medips$geo_library_source_template_type %in% c("CM"),]
# data.medips$inputNg <- ifelse(data.medips$studyTitle %in% c("PBCM","AIX"), "possibly < 10ng", "10ng")
# head(data.medips)
# dim(data.medips) #5212   87
```

Investigating the metrics across all projects

```{r, echo=FALSE}
# selecting metric 
metric <- readLines("data/metrics.txt")
meta <- readLines("data/meta.txt")

# design panel
inputPanel(
  # load run names based on project selected
  selectInput("metric", label = "Metrics for evaluation",
              choices = c("select metric name"), selected = "metric", width = 2000),
  selectInput("meta", label = "Meta for evaluation",
              choices = c("select metric name"), selected = "meta", width = 2000),
  selectInput("projecttitle", label = "subset by project name",
              choices = c("select study name"), multiple = T, selected = NULL, width = 2000),
  selectInput("runID", label = "run alias",
              choices = c("select run name"), multiple = T, selected = NULL, width = 2000),
  selectInput("groupBy", label = "group by run or project",
              choices = c("studyTitle", "Run.Alias"), selected = NULL, width = 2000),
  checkboxInput("showBoxPlot", label= "Show individual distributions", 
                  value = FALSE, width = NULL),
  checkboxInput("splitByInput", label= "split plots by input DNA", 
                  value = FALSE, width = NULL),
  checkboxInput("splitByReads", label= "expected read clusters from sequencing", 
                  value = FALSE, width = NULL),
  checkboxInput("scaleY", label = "scale Y axis", value = FALSE, width = NULL)
  # expected read clusters/sequenced at
)

observe({
  updateSelectInput(
    session,
    "metric",
    choices = metric
  )
})

observe({
  updateSelectInput(
    session,
    "meta",
    choices = meta
  )
})

runInfo <- reactive({
  runIDs <- unique(data.medips$Run.Alias)
  if (!is.null(input$`project title`)){
    runIDs <- unique(data.medips[data.medips$studyTitle %in% input$`project title`,]$Run.Alias)
  }
  return (runIDs)
})

observe({
  updateSelectInput(
    session,
    "runID",
    choices = runInfo()
  )
})

projInfo <- reactive({
  projIDs <- unique(data.medips$studyTitle)
  # if (!is.null(input$`runID`)){
  #   projIDs <- unique(data.medips[data.medips$Run.Alias %in% input$`runID`,]$studyTitle)
  # }
  return (projIDs)
})

observe({
  updateSelectInput(
    session,
    "projecttitle",
    choices = projInfo()
  )
})

```

```{r, echo=F}

# subset the data metrics based on metric and meta
updatedData <- reactive({
  if (!is.null(input$`projecttitle`)){
    data.medips <- data.medips[data.medips$studyTitle %in% input$`projecttitle`,]
  }
  if (!is.null(input$`runID`)){
    data.medips <- data.medips[data.medips$Run.Alias %in% input$`runID`,]
  }
  metric_name <- stringr::str_replace_all(as.character(input$`metric`), " ", ".")
  meta_name <-  stringr::str_replace_all(as.character(input$`meta`), " ", ".")
  group_by <- stringr::str_replace_all(as.character(input$`groupBy`), " ", ".")
  # colnames(data.medips)[colnames(data.medips) %in% c(meta_name,metric_name)]
  updated.data <- data.medips[,colnames(data.medips)[colnames(data.medips) %in% c(meta_name,metric_name)]]
  updated.data$group_by <- data.medips[,group_by]
  # additional info
  updated.data$inputNg <- ifelse(updated.data$studyTitle %in% c("PBCM","AIX"), "possibly < 10ng", "10ng")
  # adding more layers
#   AIX,60M
# PBCM,60M
# HPCC,40M
# HLCS,25M (but in the first batch, they were topped up to ~40M)
# KLCS,60M
# CMPP,60M
# NASHB,60M
# EVOLVE,60M
# WTCC,60M
# MS3,20M for Bm and 40M for Pb
  expectedRC <- c("AIX" = "60M", 
                  "PBCM" = "60M",
                  "HPCC" = "40M",
                  "HLCS" = "25M",
                  "KLCS" = "60M",
                  "CMPP" = "60M",
                  "NASHB" = "60M",
                  "EVOLVE" = "60M",
                  "WTCC" = "60M",
                  "MS3" = "20M")
  updated.data$expectedReadClustersFromSeq <- expectedRC[updated.data$studyTitle]
  # refining this 
  # updated.data[updated.data$studyTitle == "MS3" &
  #                updated.data$geo_tissue_origin == "Pb",]$expectedReadClustersFromSeq <- "40M"
  return (updated.data)
})

# renderTable({
#   head(updatedData())
# })

# plots
renderPlot({
  data.for.plot <- updatedData()
  names(data.for.plot) <- c("meta", "metric", "group_by", "inputNg", "expectedReadClustersFromSeq")
  metric_name <- input$metric
  meta_name <- input$meta
  iqr.data <- quantile(data.for.plot[,"metric"], c(0.25,0.5,0.75))
  
  plt <- ggplot(data.for.plot) 
  plt <- plt +
    geom_point(aes(x = meta, y = metric, color = meta, group = meta)) +
    geom_hline(yintercept = iqr.data[1],linetype='dotted', col = 'red') +
    geom_hline(yintercept = iqr.data[2],linetype='dotted', col = 'red') +  
    geom_hline(yintercept = iqr.data[3], linetype='dotted', col = 'red') +
    ylab(metric_name) + xlab(meta_name) + theme_classic() + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
  if (input$`showBoxPlot`){
    # groupBy <- input$`groupBy`
    plt <- plt + geom_boxplot(aes(x = meta, y = metric, group = group_by))
  }
  
  if (!input$`splitByReads`){
    # groupBy <- input$`groupBy`
    plt <- plt + facet_grid(inputNg~., space = "free")
  }
  if (!input$`splitByInput`){
    plt <- plt + facet_grid(. ~ expectedReadClustersFromSeq, space = "free")
  }
  
  if (input$`splitByReads` & input$`splitByInput`){
    plt <- plt + facet_grid(inputNg ~ expectedReadClustersFromSeq, space = "free")
  }
  
  if(input$`scaleY`){
    plt <- plt + scale_y_log10()
  }
  plt
})
# display plot of IQRs shaded for all data samples

```

